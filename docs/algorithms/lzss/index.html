<!DOCTYPE html>
<html lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=Edge">
<title>LZSS - The Hitchhiker's Guide to Compression</title>
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="/assets/css/just-the-docs-default.css"> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-2709176-10"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-2709176-10', { 'anonymize_ip': true }); </script> <script type="text/javascript" src="/assets/js/vendor/lunr.min.js"></script> <script type="text/javascript" src="/assets/js/just-the-docs.js"></script><meta name="viewport" content="width=device-width, initial-scale=1">
<title>LZSS | The Hitchhiker’s Guide to Compression</title>
<meta name="generator" content="Jekyll v4.1.1">
<meta property="og:title" content="LZSS">
<meta property="og:locale" content="en_US">
<meta name="description" content="A collection of resources and posts to help people understand compression algorithms.">
<meta property="og:description" content="A collection of resources and posts to help people understand compression algorithms.">
<link rel="canonical" href="/algorithms/lzss/">
<meta property="og:url" content="/algorithms/lzss/">
<meta property="og:site_name" content="The Hitchhiker’s Guide to Compression"> <script type="application/ld+json"> {"url":"/algorithms/lzss/","@type":"WebPage","headline":"LZSS","description":"A collection of resources and posts to help people understand compression algorithms.","@context":"https://schema.org"}</script>
</head>
<body> <svg xmlns="http://www.w3.org/2000/svg" style="display: none;"> <symbol id="svg-link" viewbox="0 0 24 24"><title>Link</title>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path> </svg> </symbol> <symbol id="svg-search" viewbox="0 0 24 24"><title>Search</title>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search"> <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line> </svg> </symbol> <symbol id="svg-menu" viewbox="0 0 24 24"><title>Menu</title>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line> </svg> </symbol> <symbol id="svg-arrow-right" viewbox="0 0 24 24"><title>Expand</title>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"><polyline points="9 18 15 12 9 6"></polyline> </svg> </symbol> <symbol id="svg-doc" viewbox="0 0 24 24"><title>Document</title>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file"><path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline> </svg> </symbol> </svg><div class="side-bar">
<div class="site-header"> <a href="/" class="site-title lh-tight"> The Hitchhiker's Guide to Compression </a> <a href="#" id="menu-button" class="site-button"> <svg viewbox="0 0 24 24" class="icon"><use xlink:href="#svg-menu"></use></svg> </a>
</div>
<nav role="navigation" aria-label="Main" id="site-nav" class="site-nav"><ul class="nav-list">
<li class="nav-list-item"><a href="/" class="nav-list-link">Overview</a></li>
<li class="nav-list-item"><a href="/getting_started/" class="nav-list-link">Getting Started</a></li>
<li class="nav-list-item active">
<a href="#" class="nav-list-expander"><svg viewbox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/algorithms/overview/" class="nav-list-link">Overview of Algorithms</a><ul class="nav-list ">
<li class="nav-list-item active">
<a href="#" class="nav-list-expander"><svg viewbox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/algorithms/lz/" class="nav-list-link">Lempel-Ziv</a><ul class="nav-list"><li class="nav-list-item active"> <a href="/algorithms/lzss/" class="nav-list-link active">LZSS</a>
</li></ul>
</li>
<li class="nav-list-item "><a href="/algorithms/dictionary/" class="nav-list-link">Dictionary Coding</a></li>
<li class="nav-list-item ">
<a href="#" class="nav-list-expander"><svg viewbox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/algorithms/huffman/" class="nav-list-link">Huffman</a><ul class="nav-list"><li class="nav-list-item "> <a href="/algorithms/huffam-program/" class="nav-list-link">Tree Building Implementation</a>
</li></ul>
</li>
<li class="nav-list-item "><a href="/algorithms/dmc/" class="nav-list-link">Dynamic Markov Compression</a></li>
<li class="nav-list-item "><a href="/algorithms/arithmetic/" class="nav-list-link">Arithmetic Coding</a></li>
</ul>
</li>
<li class="nav-list-item">
<a href="#" class="nav-list-expander"><svg viewbox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/interactive/interactive/" class="nav-list-link">Interactive Algorithms</a><ul class="nav-list ">
<li class="nav-list-item ">
<a href="#" class="nav-list-expander"><svg viewbox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/interactive/lz/lz/" class="nav-list-link">LZ77/LZSS</a><ul class="nav-list">
<li class="nav-list-item "> <a href="/interactive/lz/fullscreen_encoder/" class="nav-list-link">Fullscreen Encoder</a>
</li>
<li class="nav-list-item "> <a href="/interactive/lz/fullscreen_decoder/" class="nav-list-link">Fullscreen Decoder</a>
</li>
</ul>
</li>
<li class="nav-list-item "><a href="/interactive/arithmetic/" class="nav-list-link">Arithmetic Encoder</a></li>
</ul>
</li>
<li class="nav-list-item">
<a href="#" class="nav-list-expander"><svg viewbox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/reference/reference/" class="nav-list-link">Reference</a><ul class="nav-list ">
<li class="nav-list-item "><a href="/reference/bytes/" class="nav-list-link">Bytes and Binary</a></li>
<li class="nav-list-item "><a href="/reference/encodings/" class="nav-list-link">Character Encodings</a></li>
<li class="nav-list-item "><a href="/reference/compression_ratios/" class="nav-list-link">Compression Ratios</a></li>
<li class="nav-list-item "><a href="/reference/magic_numbers/" class="nav-list-link">Unix Magic Numbers</a></li>
<li class="nav-list-item "><a href="/reference/raisin/" class="nav-list-link">Raisin</a></li>
</ul>
</li>
<li class="nav-list-item"><a href="/resources/" class="nav-list-link">Resources</a></li>
<li class="nav-list-item"><a href="/contributing/" class="nav-list-link">Contributing</a></li>
<li class="nav-list-item"><a href="/attributions/" class="nav-list-link">Attributions</a></li>
</ul></nav><footer class="site-footer"> This site uses <a href="https://github.com/pmarsceill/just-the-docs">Just the Docs</a>, a documentation theme for Jekyll.</footer>
</div>
<div class="main" id="top">
<div id="main-header" class="main-header">
<div class="search">
<div class="search-input-wrap"> <input type="text" id="search-input" class="search-input" tabindex="0" placeholder="Search The Hitchhiker's Guide to Compression" aria-label="Search The Hitchhiker's Guide to Compression" autocomplete="off"> <label for="search-input" class="search-label"><svg viewbox="0 0 24 24" class="search-icon"><use xlink:href="#svg-search"></use></svg></label>
</div>
<div id="search-results" class="search-results"></div>
</div>
<nav aria-label="Auxiliary" class="aux-nav"><ul class="aux-nav-list">
<li class="aux-nav-list-item"> <a href="//github.com/pmarsceill/just-the-docs" class="site-button"> Just the Docs on GitHub </a>
</li>
<li class="aux-nav-list-item"> <a href="https://github.com/go-compression/go-compression.github.io" class="site-button"> View on GitHub </a>
</li>
</ul></nav>
</div>
<div id="main-content-wrap" class="main-content-wrap">
<nav aria-label="Breadcrumb" class="breadcrumb-nav"><ol class="breadcrumb-nav-list">
<li class="breadcrumb-nav-list-item"><a href="/algorithms/overview/">Overview of Algorithms</a></li>
<li class="breadcrumb-nav-list-item"><a href="/algorithms/lz/">Lempel-Ziv</a></li>
<li class="breadcrumb-nav-list-item"><span>LZSS</span></li>
</ol></nav><div id="main-content" class="main-content" role="main">
<h1 id="lempel-ziv-storer-szymanski"> <a href="#lempel-ziv-storer-szymanski" class="anchor-heading" aria-labelledby="lempel-ziv-storer-szymanski"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Lempel-Ziv-Storer-Szymanski</h1>
<p>Lempel-Ziv-Storer-Szymanski, which we’ll refer to as LZSS, is a simple variation of the common <a href="/algorithms/lz/">LZ77</a> algorithm. It uses the same token concept with an offset and length to tell the decoder where to copy the text, except it only places the token when the token is shorter than the text it is replacing.</p>
<p>The idea behind this is that it will never increase the size of a file by adding tokens everywhere for repeated letters. You can imagine that LZ77 would easily increase the file size if it simply encoded every repeated letter “e” or “i” as a token, which may take at least 5 bytes depending on the file and implementation.</p>
<h2 id="implementing-an-encoder"> <a href="#implementing-an-encoder" class="anchor-heading" aria-labelledby="implementing-an-encoder"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Implementing an Encoder</h2>
<p>Let’s take a look at some examples, so we can <em>see</em> exactly how it works. The <a href="https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Storer%E2%80%93Szymanski">wikipedia article for LZSS</a> has a great example for this, which I’ll use here, and it’s worth a read as an introduction to LZSS.</p>
<p>So let’s encode an excerpt of Dr. Seuss’s Green Eggs and Ham with LZSS (credit to Wikipedia for this example).</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>I AM SAM. I AM SAM. SAM I AM.

THAT SAM-I-AM! THAT SAM-I-AM! I DO NOT LIKE THAT SAM-I-AM!

DO WOULD YOU LIKE GREEN EGGS AND HAM?

I DO NOT LIKE THEM,SAM-I-AM.
I DO NOT LIKE GREEN EGGS AND HAM.
</code></pre></div></div>
<p>This text takes up 192 bytes in a typical UTF-8 encoding. Let’s take a look at the LZSS encoded version.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>I AM SAM. &lt;10,10&gt;SAM I AM.

THAT SAM-I-AM! T&lt;15,14&gt;I DO NOT LIKE&lt;29,15&gt;

DO WOULD YOU LIKE GREEN EGGS AND HAM?

I&lt;69,15&gt;EM,&lt;113,8&gt;.&lt;29,15&gt;GR&lt;64,16&gt;.
</code></pre></div></div>
<p>This encoded, or compressed, version only takes 148 bytes to store (without a <a href="https://linux.die.net/man/5/magic">magic type</a> to describe the file type), which is a 77% of the original file size, or a compression ratio of 1.3. Not bad!</p>
<h3 id="analysis"> <a href="#analysis" class="anchor-heading" aria-labelledby="analysis"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Analysis</h3>
<p>Now let’s take a second understand what’s happening before you start trying to conquer the world with LZSS.</p>
<p>As we can see, the “tokens” are reducing the size of the file by referencing pieces of text that are longer than the actual token. Let’s look at the first line:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>I AM SAM. &lt;10,10&gt;SAM I AM.
</code></pre></div></div>
<p>The encoder works character by character. On the first character, ‘I’, it checks it’s search buffer to see if it’s already seen an ‘I’. The search buffer is essentially the encoder’s memory, for every character it encodes, it adds it into the search buffer so it can “remember” it. Because it hasn’t seen an ‘I’ already (the search buffer is empty), it just outputs an ‘I’, adds it to the search buffer, and moves to the next character. The next character is ‘ ‘ (a space). The encoder checks the search buffer to see if it’s seen a space before, and it hasn’t so it outputs the space and moves forward.</p>
<p>Once it gets to the second space (after “I AM”), the LZ77 starts to come into play. It’s already seen a space before because it’s in the search buffer so it’s ready to output a token, but first it tries to maximize how much text the token is referencing. If it didn’t do this you could imagine that for every character it’s already seen it would output something similar to <code class="language-plaintext highlighter-rouge">&lt;5,1&gt;</code>, which is 5 times larger than any character. So once it finds a character that it’s already seen, it moves on to the next character and checks if it’s already seen the next character directly after the previous character. Once it finds a sequence of characters that it hasn’t already seen, then it goes back one character to the sequence of characters it’s already seen and prepares the token.</p>
<p>Once the token is ready, the difference between LZ77 and LZSS starts to shine. At this point LZ77 simply outputs the token, adds the characters to the search buffer and continues. LZSS does something a little smarter, it will check to see if the size of the outputted token is larger than the text it’s representing. If so, it will output the text it represents, not the token, add the text to the search buffer, and continue. If not, it will output the token, add the text it represents to the search buffer and continue.</p>
<p><img src="/assets/LZ1.png" alt=""></p>
<p>Coming back to our example, the space character has already been seen, but a space followed by an “S” hasn’t been seen yet (“ S”), so we prepare the token representing the space. The token in our case would be “&lt;3,1&gt;”, which means go back three characters and copy 1 character(s). Next we check to see if our token is longer than our text, and “&lt;3,1&gt;” is indeed longer than “ “, so it wouldn’t make sense to output the token, so we output the space, add it to our search buffer, and continue.</p>
<p>This entire process continues until we get to the “I AM SAM. “. At this point we’ve already seen an “I AM SAM. “ but haven’t seen an “I AM SAM. S” so we know our token will represent “I AM SAM. “. Then we check to see if “I AM SAM. “ is longer than “&lt;10,10&gt;”, which it is, so we output the token, add the text to our search buffer and go along.</p>
<p><img src="/assets/LZ2.png" alt=""></p>
<p>This process continues, encoding tokens and adding text to the search buffer character by character until it’s finished encoding everything.</p>
<h3 id="takeaways"> <a href="#takeaways" class="anchor-heading" aria-labelledby="takeaways"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Takeaways</h3>
<p>There’s a lot of information to unpack here, but the algorithm at a high level is quite simple:</p>
<ul>
<li>Loop character by character</li>
<li>Check if it’s seen the character before<ul>
<li>If so, check the next character and prepare a token to be outputted<ul>
<li>If the token is longer than the text it’s representing, don’t output a token</li>
<li>Add the text to the search buffer and continue</li>
</ul>
</li>
<li>If not, add the character to the search buffer and continue</li>
</ul>
</li>
</ul>
<p>It’s important to remember that no matter the outcome, token or no token, the text is always appended to the search buffer so it can always “remember” the text it’s already seen.</p>
<h2 id="implementation"> <a href="#implementation" class="anchor-heading" aria-labelledby="implementation"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Implementation</h2>
<p>Now let’s take a stab at building our very own version so we can understand it more deeply.</p>
<p>As with most of these algorithms, we have an implementation written in Go in our <a href="https://github.com/go-compression/raisin">raisin project</a>. If you’re interested in what a more performant or real-world example of these algorithms looks like, be sure to check it out. However for this guide we’ll use Python to make it more approachable so we can focus on understanding the algorithm and not the nuances of the language.</p>
<h3 id="character-loop"> <a href="#character-loop" class="anchor-heading" aria-labelledby="character-loop"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Character Loop</h3>
<p>Let’s get started with a simple loop that goes over each character for encoding. As we can see from our <a href="#takeaways">takeaways</a>, the character-by-character loop is what powers LZSS.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">text</span> <span class="o">=</span> <span class="s">"HELLO"</span>
<span class="n">encoding</span> <span class="o">=</span> <span class="s">"utf-8"</span>

<span class="n">text_bytes</span> <span class="o">=</span> <span class="n">text</span><span class="p">.</span><span class="n">encode</span><span class="p">(</span><span class="n">encoding</span><span class="p">)</span>

<span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">text_bytes</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="nb">bytes</span><span class="p">([</span><span class="n">char</span><span class="p">]).</span><span class="n">decode</span><span class="p">(</span><span class="n">encoding</span><span class="p">))</span> <span class="c1"># Print the character
</span></code></pre></div></div>
<p>Output:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>H
E
L
L
O
</code></pre></div></div>
<p>Although the code is functionally pretty simple, there’s a few important things going on here. You can see that looping character-by-character isn’t as simple as <code class="language-plaintext highlighter-rouge">for char in text</code>, first we have to encode it and then loop over the encoding. This is because it converts our string into an array of <a href="/reference/reference/">bytes</a>, represented as a Python object called <code class="language-plaintext highlighter-rouge">bytes</code>. When we print the character out, we have to convert it from a byte (represented as a Python <code class="language-plaintext highlighter-rouge">int</code>) back to a string so we can see it.</p>
<p>The reason we do this is because a byte is really just a number from 0-255 as it is represented in your computer as 8 1’s and 0’s, called <a href="https://en.wikipedia.org/wiki/Binary_code">binary</a>. If you don’t already have a basic understanding of how computers store our language, you should get acquainted with it on our <a href="/getting_started/">getting started</a> page.</p>
<h3 id="search-buffers"> <a href="#search-buffers" class="anchor-heading" aria-labelledby="search-buffers"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Search Buffers</h3>
<p>Great, we have a basic program working which can loop over our text and print it out, but that’s pretty far off from compression so let’s keep going. The next step to our program is to implement our “memory” so the program can check to see if its already seen a character.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">text</span> <span class="o">=</span> <span class="s">"HELLO"</span>
<span class="n">encoding</span> <span class="o">=</span> <span class="s">"utf-8"</span>

<span class="n">text_bytes</span> <span class="o">=</span> <span class="n">text</span><span class="p">.</span><span class="n">encode</span><span class="p">(</span><span class="n">encoding</span><span class="p">)</span>

<span class="n">search_buffer</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># Array of integers, representing bytes
</span>
<span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">text_bytes</span><span class="p">:</span>
	<span class="k">print</span><span class="p">(</span><span class="nb">bytes</span><span class="p">([</span><span class="n">char</span><span class="p">]).</span><span class="n">decode</span><span class="p">(</span><span class="n">encoding</span><span class="p">))</span> <span class="c1"># Print the character
</span>    <span class="n">search_buffer</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">char</span><span class="p">)</span> <span class="c1"># Add the character to our search buffer
</span></code></pre></div></div>
<p>We no longer need to output anything as we’re just adding each character to the search buffer with the <code class="language-plaintext highlighter-rouge">append</code> method.</p>
<h3 id="checking-our-search-buffer"> <a href="#checking-our-search-buffer" class="anchor-heading" aria-labelledby="checking-our-search-buffer"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Checking Our Search buffer</h3>
<p>Now let’s try to implement the LZ part of LZSS, we need to start looking <strong>backwards</strong> for characters we’ve already seen. This can accomplished quite easily using the <code class="language-plaintext highlighter-rouge">list.index</code> method.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">text_bytes</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">search_buffer</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">f"Found at </span><span class="si">{</span><span class="n">search_buffer</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="n">char</span><span class="p">)</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>

    <span class="k">print</span><span class="p">(</span><span class="nb">bytes</span><span class="p">([</span><span class="n">char</span><span class="p">]).</span><span class="n">decode</span><span class="p">(</span><span class="n">encoding</span><span class="p">))</span> <span class="c1"># Print the character
</span>    <span class="n">search_buffer</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">char</span><span class="p">)</span> <span class="c1"># Add the character to our search buffer
</span></code></pre></div></div>
<p>Output:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>H
E
L
Found at 2
L
O
</code></pre></div></div>
<p>Notice the <code class="language-plaintext highlighter-rouge">if char in search_buffer</code>, without this Python will throw an <code class="language-plaintext highlighter-rouge">IndexError</code> if the value is not in the list.</p>
<h3 id="building-tokens"> <a href="#building-tokens" class="anchor-heading" aria-labelledby="building-tokens"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Building Tokens</h3>
<p>Now let’s build a token and output it when we find the character.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">text_bytes</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">search_buffer</span><span class="p">:</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">search_buffer</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="n">char</span><span class="p">)</span> <span class="c1"># The index where the character appears in our search buffer
</span>        <span class="n">offset</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">index</span> <span class="c1"># Calculate the relative offset
</span>        <span class="n">length</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># Set the length of the token (how many character it represents)
</span>
        <span class="k">print</span><span class="p">(</span><span class="s">f"&lt;</span><span class="si">{</span><span class="n">offset</span><span class="si">}</span><span class="s">,</span><span class="si">{</span><span class="n">length</span><span class="si">}</span><span class="s">&gt;"</span><span class="p">)</span> <span class="c1"># Build and print our token
</span>    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="nb">bytes</span><span class="p">([</span><span class="n">char</span><span class="p">]).</span><span class="n">decode</span><span class="p">(</span><span class="n">encoding</span><span class="p">))</span> <span class="c1"># Print the character
</span>
    <span class="n">search_buffer</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">char</span><span class="p">)</span> <span class="c1"># Add the character to our search buffer
</span>
    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
</code></pre></div></div>
<p>Output:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>H
E
L
&lt;1,1&gt;
O
</code></pre></div></div>
<p>We’re nearly there! This is actually a rough implementation of LZ77, however there’s one issue. If we have a word that repeats twice, it will copy each character instead of the <strong>entire word</strong>.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>text = "SAM SAM"
</code></pre></div></div>
<p>Output</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>S
A
M

&lt;4,1&gt;
&lt;4,1&gt;
&lt;4,1&gt;
</code></pre></div></div>
<blockquote><p>Note: <code class="language-plaintext highlighter-rouge">&lt;4,1&gt;</code> is technically correct as each character is represented 4 characters behind the beginning of the token.</p></blockquote>
<p>That’s not exactly right, we should see <code class="language-plaintext highlighter-rouge">&lt;4,3&gt;</code> instead of three <code class="language-plaintext highlighter-rouge">&lt;4,1&gt;</code> tokens. So let’s write some code that can check our search buffer for more than one character.</p>
<h3 id="checking-the-search-buffer-for-more-characters"> <a href="#checking-the-search-buffer-for-more-characters" class="anchor-heading" aria-labelledby="checking-the-search-buffer-for-more-characters"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Checking the Search Buffer for More Characters</h3>
<p>Let’s modify our code to check the search buffer for more than one character.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">elements_in_array</span><span class="p">(</span><span class="n">check_elements</span><span class="p">,</span> <span class="n">elements</span><span class="p">):</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">elements</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">check_elements</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">offset</span><span class="p">:</span>
            <span class="c1"># All of the elements in check_elements are in elements
</span>            <span class="k">return</span> <span class="n">i</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">check_elements</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">check_elements</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">==</span> <span class="n">element</span><span class="p">:</span>
            <span class="n">offset</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

<span class="n">text</span> <span class="o">=</span> <span class="s">"SAM SAM"</span>
<span class="n">encoding</span> <span class="o">=</span> <span class="s">"utf-8"</span>

<span class="n">text_bytes</span> <span class="o">=</span> <span class="n">text</span><span class="p">.</span><span class="n">encode</span><span class="p">(</span><span class="n">encoding</span><span class="p">)</span>

<span class="n">search_buffer</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># Array of integers, representing bytes
</span><span class="n">check_characters</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># Array of integers, representing bytes
</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">text_bytes</span><span class="p">:</span>
    <span class="n">check_characters</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">elements_in_array</span><span class="p">(</span><span class="n">check_characters</span><span class="p">,</span> <span class="n">search_buffer</span><span class="p">)</span> <span class="c1"># The index where the characters appears in our search buffer
</span>
    <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">text_bytes</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">check_characters</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">elements_in_array</span><span class="p">(</span><span class="n">check_characters</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">search_buffer</span><span class="p">)</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">index</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">check_characters</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1"># Calculate the relative offset
</span>            <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">check_characters</span><span class="p">)</span> <span class="c1"># Set the length of the token (how many character it represents)
</span>
            <span class="k">print</span><span class="p">(</span><span class="s">f"&lt;</span><span class="si">{</span><span class="n">offset</span><span class="si">}</span><span class="s">,</span><span class="si">{</span><span class="n">length</span><span class="si">}</span><span class="s">&gt;"</span><span class="p">)</span> <span class="c1"># Build and print our token
</span>        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="nb">bytes</span><span class="p">([</span><span class="n">char</span><span class="p">]).</span><span class="n">decode</span><span class="p">(</span><span class="n">encoding</span><span class="p">))</span> <span class="c1"># Print the character
</span>
        <span class="n">check_characters</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">search_buffer</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">char</span><span class="p">)</span> <span class="c1"># Add the character to our search buffer
</span>
    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
</code></pre></div></div>
<p>Output:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>S
A
M

&lt;4,3&gt;
</code></pre></div></div>
<p>It works! But there’s quite a lot to unpack here so let’s go through it line by line.</p>
<p>The first and largest addition is the <code class="language-plaintext highlighter-rouge">elements_in_array</code> function. The code here essentially checks to see if specific elements are within an array in an exact order. If so, it will return the index in the array where the elements start, and if not it will return -1.</p>
<p>Moving on to our main function loop we can see now have <code class="language-plaintext highlighter-rouge">check_characters</code> defined at the top. This variable tracks what characters we’re looking for in our <code class="language-plaintext highlighter-rouge">search_buffer</code>. As we loop through, we use <code class="language-plaintext highlighter-rouge">check_characters.append(char)</code> to add the current character to the characters we’re searching. Then we check to see if <code class="language-plaintext highlighter-rouge">check_characters</code> can be found within <code class="language-plaintext highlighter-rouge">search_buffer</code> with <code class="language-plaintext highlighter-rouge">elements_in_array</code>.</p>
<p>Now we have the best part: the logic. If we couldn’t find a match or it’s the last character we want to output something. If we couldn’t find more than one character in the <code class="language-plaintext highlighter-rouge">search_buffer</code> then that means <code class="language-plaintext highlighter-rouge">check_characters</code> minus the last character was found, so we’ll output a token representing <code class="language-plaintext highlighter-rouge">check_characters</code> minus the last character. Otherwise, we couldn’t find a match for a single character so let’s just output that character.</p>
<p>And that’s essentially LZ77! Try it out for yourself with some different strings to see for yourself. However you might notice that we’re trying to implement LZSS, not LZ77, so we have one more piece to implement.</p>
<h3 id="comparing-token-sizes"> <a href="#comparing-token-sizes" class="anchor-heading" aria-labelledby="comparing-token-sizes"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Comparing Token Sizes</h3>
<p>This crucial piece is the process described earlier of comparing the size of tokens versus the text it represents. Essentially we’re saying, if the token takes up more space than the text it’s representing then don’t output a token, just output the text. <img src="/assets/LZ1.png" alt=""></p>
<p>Lucky for us this is a pretty simple change. Our main loop now looks like so:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">text_bytes</span><span class="p">:</span>
    <span class="n">check_characters</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">elements_in_array</span><span class="p">(</span><span class="n">check_characters</span><span class="p">,</span> <span class="n">search_buffer</span><span class="p">)</span> <span class="c1"># The index where the characters appears in our search buffer
</span>
    <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">text_bytes</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">check_characters</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">elements_in_array</span><span class="p">(</span><span class="n">check_characters</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">search_buffer</span><span class="p">)</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">index</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">check_characters</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1"># Calculate the relative offset
</span>            <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">check_characters</span><span class="p">)</span> <span class="c1"># Set the length of the token (how many character it represents)
</span>
            <span class="n">token</span> <span class="o">=</span> <span class="s">f"&lt;</span><span class="si">{</span><span class="n">offset</span><span class="si">}</span><span class="s">,</span><span class="si">{</span><span class="n">length</span><span class="si">}</span><span class="s">&gt;"</span> <span class="c1"># Build our token
</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">length</span><span class="p">:</span>
                <span class="c1"># Length of token is greater than the length it represents, so output the character
</span>                <span class="k">print</span><span class="p">(</span><span class="nb">bytes</span><span class="p">(</span><span class="n">check_characters</span><span class="p">).</span><span class="n">decode</span><span class="p">(</span><span class="n">encoding</span><span class="p">))</span> <span class="c1"># Print the characters
</span>            <span class="k">else</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="c1"># Print our token
</span>        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="nb">bytes</span><span class="p">([</span><span class="n">char</span><span class="p">]).</span><span class="n">decode</span><span class="p">(</span><span class="n">encoding</span><span class="p">))</span> <span class="c1"># Print the character
</span>
        <span class="n">check_characters</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">search_buffer</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">char</span><span class="p">)</span> <span class="c1"># Add the character to our search buffer
</span>
    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
</code></pre></div></div>
<p>Output:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>S
A
M

SAM
</code></pre></div></div>
<p>The key is the <code class="language-plaintext highlighter-rouge">len(token) &gt; length</code> which checks if the length of the token is longer than the length of the text it’s representing. If it is, it simply outputs the characters, otherwise it outputs the token.</p>
<h3 id="sliding-windows"> <a href="#sliding-windows" class="anchor-heading" aria-labelledby="sliding-windows"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Sliding Windows</h3>
<p>The last piece to the puzzle is something you might have noticed if you’re already trying to compress large file: the search buffer gets <strong>big</strong>. Let’s say we’re compressing a 1 Gb file. After we go over each character, we add it to the search buffer and continue, though each iteration we also search the entire search buffer for certain characters. This quickly adds up for larger files. In our 1 Gb file scenario, near the end we’ll have to search almost 1 billion bytes to <strong>encode a single character</strong>.</p>
<p>It should be pretty obvious that this <em>very inefficient</em>. And unfortunately, there is no magic solution, you have to make a tradeoff. With every compression algorithm you have to decide between speed and compression ratio. Do you want a fast algorithm that can’t reduce the file size very much, or a slow algorithm that reduces the file size more? The answer is: it depends. And so, the tradeoff in LZ77’s case is to create a “sliding window”. <img src="/assets/LZ3.png" alt=""></p>
<p>The “sliding window” is actually quite simple, all you do is cap off the maximum size of the search buffer. When you add a character to the search buffer that makes it larger than the maximum size of the sliding window then you remove the first character. That way the window is “sliding” as you move through the file, and the algorithm doesn’t slow down!</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">max_sliding_window_size</span> <span class="o">=</span> <span class="mi">4096</span>

<span class="p">...</span>

<span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">text_bytes</span><span class="p">:</span>

	<span class="p">...</span>

    <span class="n">search_buffer</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">char</span><span class="p">)</span> <span class="c1"># Add the character to our search buffer
</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">search_buffer</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_sliding_window_size</span><span class="p">:</span> <span class="c1"># Check to see if it exceeds the max_sliding_window_size
</span>        <span class="n">search_buffer</span> <span class="o">=</span> <span class="n">search_buffer</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="c1"># Remove the first element from the search_buffer
</span>
    <span class="p">...</span>
</code></pre></div></div>
<p>These changes should be pretty self-explanatory. We’re just checking to see if the length of the <code class="language-plaintext highlighter-rouge">search_buffer</code> is greater than the <code class="language-plaintext highlighter-rouge">max_sliding_window_size</code>, and if so we pop the first element off of the <code class="language-plaintext highlighter-rouge">search_buffer</code>.</p>
<p>Keep in mind that while a maximum sliding window size of 4096 character is typical, it may be hard to use during testing, try setting it much lower (like 3-4) and test it with some different strings to see how it works.</p>
<h3 id="putting-it-all-together"> <a href="#putting-it-all-together" class="anchor-heading" aria-labelledby="putting-it-all-together"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Putting it all together</h3>
<p>That’s everything that makes up LZSS, but for the sake of completing our example, let’s clean it up so we can call a function with some text, an optional <code class="language-plaintext highlighter-rouge">max_sliding_window_size</code>, and have it return the encoded text, rather than just printing it out.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">encoding</span> <span class="o">=</span> <span class="s">"utf-8"</span>

<span class="k">def</span> <span class="nf">encode</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">max_sliding_window_size</span><span class="o">=</span><span class="mi">4096</span><span class="p">):</span>
	<span class="n">text_bytes</span> <span class="o">=</span> <span class="n">text</span><span class="p">.</span><span class="n">encode</span><span class="p">(</span><span class="n">encoding</span><span class="p">)</span>

    <span class="n">search_buffer</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># Array of integers, representing bytes
</span>    <span class="n">check_characters</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># Array of integers, representing bytes
</span>    <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># Output array
</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">text_bytes</span><span class="p">:</span>
        <span class="n">check_characters</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">elements_in_array</span><span class="p">(</span><span class="n">check_characters</span><span class="p">,</span> <span class="n">search_buffer</span><span class="p">)</span> <span class="c1"># The index where the characters appears in our search buffer
</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">text_bytes</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">check_characters</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">elements_in_array</span><span class="p">(</span><span class="n">check_characters</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">search_buffer</span><span class="p">)</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">index</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">check_characters</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1"># Calculate the relative offset
</span>                <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">check_characters</span><span class="p">)</span> <span class="c1"># Set the length of the token (how many character it represents)
</span>
                <span class="n">token</span> <span class="o">=</span> <span class="s">f"&lt;</span><span class="si">{</span><span class="n">offset</span><span class="si">}</span><span class="s">,</span><span class="si">{</span><span class="n">length</span><span class="si">}</span><span class="s">&gt;"</span> <span class="c1"># Build our token
</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">length</span><span class="p">:</span>
                    <span class="c1"># Length of token is greater than the length it represents, so output the character
</span>                    <span class="n">output</span><span class="p">.</span><span class="n">extend</span><span class="p">(</span><span class="n">check_characters</span><span class="p">)</span> <span class="c1"># Output the characters
</span>                <span class="k">else</span><span class="p">:</span>
                    <span class="n">output</span><span class="p">.</span><span class="n">extend</span><span class="p">(</span><span class="n">token</span><span class="p">.</span><span class="n">encode</span><span class="p">(</span><span class="n">encoding</span><span class="p">))</span> <span class="c1"># Output our token
</span>            <span class="k">else</span><span class="p">:</span>
                <span class="n">output</span><span class="p">.</span><span class="n">extend</span><span class="p">(</span><span class="n">check_characters</span><span class="p">)</span> <span class="c1"># Output the character
</span>
            <span class="n">check_characters</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">search_buffer</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">char</span><span class="p">)</span> <span class="c1"># Add the character to our search buffer
</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">search_buffer</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_sliding_window_size</span><span class="p">:</span> <span class="c1"># Check to see if it exceeds the max_sliding_window_size
</span>            <span class="n">search_buffer</span> <span class="o">=</span> <span class="n">search_buffer</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="c1"># Remove the first element from the search_buffer
</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">encode</span><span class="p">(</span><span class="s">"SAM SAM"</span><span class="p">,</span> <span class="mi">1</span><span class="p">).</span><span class="n">decode</span><span class="p">(</span><span class="n">encoding</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">encode</span><span class="p">(</span><span class="s">"supercalifragilisticexpialidocious supercalifragilisticexpialidocious"</span><span class="p">,</span> <span class="mi">1024</span><span class="p">).</span><span class="n">decode</span><span class="p">(</span><span class="n">encoding</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">encode</span><span class="p">(</span><span class="s">"LZSS will take over the world!"</span><span class="p">,</span> <span class="mi">256</span><span class="p">).</span><span class="n">decode</span><span class="p">(</span><span class="n">encoding</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">encode</span><span class="p">(</span><span class="s">"It even works with 😀s thanks to UTF-8"</span><span class="p">,</span> <span class="mi">16</span><span class="p">).</span><span class="n">decode</span><span class="p">(</span><span class="n">encoding</span><span class="p">))</span>
</code></pre></div></div>
<p>The function definition is pretty simple, we can just move our <code class="language-plaintext highlighter-rouge">text</code> and <code class="language-plaintext highlighter-rouge">max_sliding_window_size</code> outside of the function and wrap our code in a function definition. Then we simply call it with some different values to test it, and that’s it!</p>
<p>The finished code can be found in <a href="https://github.com/go-compression/examples/blob/master/lz/lzss/lzss_encoder.py">lzss.py</a> in the examples GitHub repo.</p>
<p>Lastly, there’s a few bug in our program that we encounter with larger files. If we have some text, for example:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ISAM YAM SAM
</code></pre></div></div>
<p>When the encoder gets to the space right before the “SAM”, it will look for a space in the search buffer which it finds. Then it will search for a space and an “S” (“ S”) which it doesn’t find, so it continues and starts looking for an “A”. The issue here is that it skips looking for an “S” and continues to encode the “AM” not the “SAM”.</p>
<p>In some rare circumstances the code may generate a reference that with a length that is larger than its offset which will result in an error.</p>
<p>To fix this, we’ll need to rewrite the logic in our encoder a little bit.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">text_bytes</span><span class="p">:</span>
	<span class="n">index</span> <span class="o">=</span> <span class="n">elements_in_array</span><span class="p">(</span><span class="n">check_characters</span><span class="p">,</span> <span class="n">search_buffer</span><span class="p">)</span> <span class="c1"># The index where the characters appears in our search buffer
</span>
	<span class="k">if</span> <span class="n">elements_in_array</span><span class="p">(</span><span class="n">check_characters</span> <span class="o">+</span> <span class="p">[</span><span class="n">char</span><span class="p">],</span> <span class="n">search_buffer</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">text_bytes</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
		<span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">text_bytes</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">elements_in_array</span><span class="p">(</span><span class="n">check_characters</span> <span class="o">+</span> <span class="p">[</span><span class="n">char</span><span class="p">],</span> <span class="n">search_buffer</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
			<span class="c1"># Only if it's the last character then add the next character to the text the token is representing
</span>			<span class="n">check_characters</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>

		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">check_characters</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
			<span class="n">index</span> <span class="o">=</span> <span class="n">elements_in_array</span><span class="p">(</span><span class="n">check_characters</span><span class="p">,</span> <span class="n">search_buffer</span><span class="p">)</span>
			<span class="n">offset</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">index</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">check_characters</span><span class="p">)</span> <span class="c1"># Calculate the relative offset
</span>			<span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">check_characters</span><span class="p">)</span> <span class="c1"># Set the length of the token (how many character it represents)
</span>
			<span class="n">token</span> <span class="o">=</span> <span class="s">f"&lt;</span><span class="si">{</span><span class="n">offset</span><span class="si">}</span><span class="s">,</span><span class="si">{</span><span class="n">length</span><span class="si">}</span><span class="s">&gt;"</span> <span class="c1"># Build our token
</span>
			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">length</span><span class="p">:</span>
				<span class="c1"># Length of token is greater than the length it represents, so output the characters
</span>				<span class="n">output</span><span class="p">.</span><span class="n">extend</span><span class="p">(</span><span class="n">check_characters</span><span class="p">)</span> <span class="c1"># Output the characters
</span>			<span class="k">else</span><span class="p">:</span>
				<span class="n">output</span><span class="p">.</span><span class="n">extend</span><span class="p">(</span><span class="n">token</span><span class="p">.</span><span class="n">encode</span><span class="p">(</span><span class="n">encoding</span><span class="p">))</span> <span class="c1"># Output our token
</span>
			<span class="n">search_buffer</span><span class="p">.</span><span class="n">extend</span><span class="p">(</span><span class="n">check_characters</span><span class="p">)</span> <span class="c1"># Add the characters to our search buffer
</span>		<span class="k">else</span><span class="p">:</span>
			<span class="n">output</span><span class="p">.</span><span class="n">extend</span><span class="p">(</span><span class="n">check_characters</span><span class="p">)</span> <span class="c1"># Output the character
</span>			<span class="n">search_buffer</span><span class="p">.</span><span class="n">extend</span><span class="p">(</span><span class="n">check_characters</span><span class="p">)</span> <span class="c1"># Add the characters to our search buffer
</span>
		<span class="n">check_characters</span> <span class="o">=</span> <span class="p">[]</span>

	<span class="n">check_characters</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>

	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">search_buffer</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_sliding_window_size</span><span class="p">:</span> <span class="c1"># Check to see if it exceeds the max_sliding_window_size
</span>		<span class="n">search_buffer</span> <span class="o">=</span> <span class="n">search_buffer</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="c1"># Remove the first element from the search_buffer
</span>
	<span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
</code></pre></div></div>
<p>To fix the first issue we add the current <code class="language-plaintext highlighter-rouge">char</code> to <code class="language-plaintext highlighter-rouge">check_characters</code> only at the end and check to see if <code class="language-plaintext highlighter-rouge">check_characters + [char]</code> is found. If not we know that <code class="language-plaintext highlighter-rouge">check_characters</code> is found so we can continue as normal, and <code class="language-plaintext highlighter-rouge">check_characters</code> gets cleared before <code class="language-plaintext highlighter-rouge">char</code> is added onto <code class="language-plaintext highlighter-rouge">check_characters</code> for the next iteration. We also implement a check on the last iteration to add the current <code class="language-plaintext highlighter-rouge">char</code> to <code class="language-plaintext highlighter-rouge">check_characters</code> as otherwise our logic wouldn’t be run on the last character and a token wouldn’t be created.</p>
<p>To resolve the other problem we simply have to move the <code class="language-plaintext highlighter-rouge">search_buffer.append(char)</code> calls up into our logic and change them to <code class="language-plaintext highlighter-rouge">search_buffer.extend(check_characters)</code>. This way we only update our search buffer when we’ve already tried to find a token.</p>
<h2 id="implementing-a-decoder"> <a href="#implementing-a-decoder" class="anchor-heading" aria-labelledby="implementing-a-decoder"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Implementing a Decoder</h2>
<p>What’s the use of encoding something some text if we can’t decode it? For that we’ll need to build ourselves a decoder.</p>
<p>Luckily for us, building a decoder is actually much simpler than an encoder because all it needs to know how to do is convert a token (“&lt;5,2&gt;”) into the literal text it represents. The decoder doesn’t care about search buffers, sliding windows, or token lengths, it only has one job.</p>
<p>So, let’s get started. We’re going to decode character-by-character just like our encoder so we’ll start with our main loop inside of a function. We’ll also need to encode and decode the strings so we’ll keep the <code class="language-plaintext highlighter-rouge">encoding = "utf-8"</code>.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">encoding</span> <span class="o">=</span> <span class="s">"utf-8"</span>

<span class="k">def</span> <span class="nf">decode</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>

    <span class="n">text_bytes</span> <span class="o">=</span> <span class="n">text</span><span class="p">.</span><span class="n">encode</span><span class="p">(</span><span class="n">encoding</span><span class="p">)</span> <span class="c1"># The text encoded as bytes
</span>    <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># The output characters
</span>
    <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">text_bytes</span><span class="p">:</span>
        <span class="n">output</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">char</span><span class="p">)</span> <span class="c1"># Add the character to our output
</span>
    <span class="k">return</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">decode</span><span class="p">(</span><span class="s">"supercalifragilisticexpialidocious &lt;35,34&gt;"</span><span class="p">).</span><span class="n">decode</span><span class="p">(</span><span class="n">encoding</span><span class="p">))</span>
</code></pre></div></div>
<p>Here we’re setting up the structure for the rest of our decoder by setting up our main loop and declaring everything within a neat self-contained function.</p>
<h3 id="identifying-tokens"> <a href="#identifying-tokens" class="anchor-heading" aria-labelledby="identifying-tokens"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Identifying Tokens</h3>
<p>The next step is to start doing some actual decoding. The goal of our decoder is to convert a token into text, so we need to first identify a token and extract our <code class="language-plaintext highlighter-rouge">offset</code> and <code class="language-plaintext highlighter-rouge">length</code> before we can convert it into text. <img src="/assets/LZ4.png" alt=""></p>
<blockquote><p>Notice the various components of a token that need to be identified and extracted so we can find the text they represent</p></blockquote>
<p>Let’s make a small change so we can identify the start and end of a token.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">text_bytes</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">char</span> <span class="o">==</span> <span class="s">"&lt;"</span><span class="p">.</span><span class="n">encode</span><span class="p">(</span><span class="n">encoding</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">"Found opening of a token"</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">char</span> <span class="o">==</span> <span class="s">"&gt;"</span><span class="p">.</span><span class="n">encode</span><span class="p">(</span><span class="n">encoding</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">"Found closing of a token"</span><span class="p">)</span>

        <span class="n">output</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">char</span><span class="p">)</span> <span class="c1"># Add the character to our output
</span>
    <span class="k">return</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
</code></pre></div></div>
<p>Because we’re going character-by-character we can simply check to see if the character is a token opening character or closing character to tell if we’re inside a token. Let’s add some more code to track the numbers between the comma, our seperator.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">inside_token</span> <span class="o">=</span> <span class="bp">False</span>
<span class="n">scanning_offset</span> <span class="o">=</span> <span class="bp">True</span>

<span class="n">length</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># Length number encoded as bytes
</span><span class="n">offset</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># Offset number encoded as bytes
</span>
<span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">text_bytes</span><span class="p">:</span>
	<span class="k">if</span> <span class="n">char</span> <span class="o">==</span> <span class="s">"&lt;"</span><span class="p">.</span><span class="n">encode</span><span class="p">(</span><span class="n">encoding</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
		<span class="n">inside_token</span> <span class="o">=</span> <span class="bp">True</span> <span class="c1"># We're now inside a token
</span>		<span class="n">scanning_offset</span> <span class="o">=</span> <span class="bp">True</span> <span class="c1"># We're now looking for the length number
</span>	<span class="k">elif</span> <span class="n">char</span> <span class="o">==</span> <span class="s">","</span><span class="p">.</span><span class="n">encode</span><span class="p">(</span><span class="n">encoding</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
		<span class="n">scanning_offset</span> <span class="o">=</span> <span class="bp">False</span>
	<span class="k">elif</span> <span class="n">char</span> <span class="o">==</span> <span class="s">"&gt;"</span><span class="p">.</span><span class="n">encode</span><span class="p">(</span><span class="n">encoding</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">inside_token</span><span class="p">:</span>
		<span class="n">inside_token</span> <span class="o">=</span> <span class="bp">False</span> <span class="c1"># We're no longer inside a token
</span>
		<span class="c1"># Convert length and offsets to an integer
</span>		<span class="n">length_num</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">bytes</span><span class="p">(</span><span class="n">length</span><span class="p">).</span><span class="n">decode</span><span class="p">(</span><span class="n">encoding</span><span class="p">))</span>
		<span class="n">offset_num</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">bytes</span><span class="p">(</span><span class="n">offset</span><span class="p">).</span><span class="n">decode</span><span class="p">(</span><span class="n">encoding</span><span class="p">))</span>

		<span class="k">print</span><span class="p">(</span><span class="s">f"Found token with length: </span><span class="si">{</span><span class="n">length_num</span><span class="si">}</span><span class="s">, offset: </span><span class="si">{</span><span class="n">offset_num</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>

		<span class="c1"># Reset length and offset
</span>		<span class="n">length</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
	<span class="k">elif</span> <span class="n">inside_token</span><span class="p">:</span>
		<span class="k">if</span> <span class="n">scanning_offset</span><span class="p">:</span>
			<span class="n">offset</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">length</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>

	<span class="n">output</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">char</span><span class="p">)</span> <span class="c1"># Add the character to our output
</span></code></pre></div></div>
<p>Output:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Found token with length: 34, offset: 35
supercalifragilisticexpialidocious &lt;35,34&gt;
</code></pre></div></div>
<p>We now have a bunch of <code class="language-plaintext highlighter-rouge">if</code> statements that give our loop some more control flow. Let’s go over the changes.</p>
<p>First off we have four new variables outside of the loop:</p>
<ul>
<li>
<code class="language-plaintext highlighter-rouge">inside_token</code> - Tracks whether or not we’re inside a token</li>
<li>
<code class="language-plaintext highlighter-rouge">scanning_offset</code> - Tracks whether we’re currently scanning for the offset number or the length number (1st or 2nd number in the token)</li>
<li>
<code class="language-plaintext highlighter-rouge">length</code> - Used to store the bytes (or characters) that represent the token’s length</li>
<li>
<code class="language-plaintext highlighter-rouge">offset</code>- Used to store the bytes (or characters) that represent the token’s offset</li>
</ul>
<p>Inside of the loop, we check if the character is a <code class="language-plaintext highlighter-rouge">&lt;</code>, <code class="language-plaintext highlighter-rouge">,</code>, or a <code class="language-plaintext highlighter-rouge">&gt;</code> and modify the variables accordingly to track where we are. If the character isn’t any of those <strong>and we’re inside a token</strong> then we want to add the character to either the offset or length because that means the character is an offset or length.</p>
<p>Lastly, if the character is a <code class="language-plaintext highlighter-rouge">&gt;</code>, that means we’re exiting the token, so let’s convert our <code class="language-plaintext highlighter-rouge">length</code> and <code class="language-plaintext highlighter-rouge">offset</code> into a Python <code class="language-plaintext highlighter-rouge">int</code>. We have to do this because they’re currently represented as a list of bytes, so we need to convert those bytes into a Python string and convert that string into an <code class="language-plaintext highlighter-rouge">int</code>. Then we finally print that we’ve found a token.</p>
<h3 id="translating-tokens"> <a href="#translating-tokens" class="anchor-heading" aria-labelledby="translating-tokens"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Translating Tokens</h3>
<p>Now we have one last step left: translating tokens into the text they represent. Thanks to <a href="https://stackoverflow.com/questions/509211/understanding-slice-notation">Python list slicing</a> this is quite simple.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">text_bytes</span><span class="p">:</span>
	<span class="k">if</span> <span class="n">char</span> <span class="o">==</span> <span class="s">"&lt;"</span><span class="p">.</span><span class="n">encode</span><span class="p">(</span><span class="n">encoding</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
		<span class="n">inside_token</span> <span class="o">=</span> <span class="bp">True</span> <span class="c1"># We're now inside a token
</span>		<span class="n">scanning_offset</span> <span class="o">=</span> <span class="bp">True</span> <span class="c1"># We're now looking for the length number
</span>		<span class="n">token_start</span> <span class="o">=</span> <span class="n">i</span>
	<span class="k">elif</span> <span class="n">char</span> <span class="o">==</span> <span class="s">","</span><span class="p">.</span><span class="n">encode</span><span class="p">(</span><span class="n">encoding</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
		<span class="n">scanning_offset</span> <span class="o">=</span> <span class="bp">False</span>
	<span class="k">elif</span> <span class="n">char</span> <span class="o">==</span> <span class="s">"&gt;"</span><span class="p">.</span><span class="n">encode</span><span class="p">(</span><span class="n">encoding</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">inside_token</span><span class="p">:</span>
		<span class="n">inside_token</span> <span class="o">=</span> <span class="bp">False</span> <span class="c1"># We're no longer inside a token
</span>
		<span class="c1"># Convert length and offsets to an integer
</span>		<span class="n">length_num</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">bytes</span><span class="p">(</span><span class="n">length</span><span class="p">).</span><span class="n">decode</span><span class="p">(</span><span class="n">encoding</span><span class="p">))</span>
		<span class="n">offset_num</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">bytes</span><span class="p">(</span><span class="n">offset</span><span class="p">).</span><span class="n">decode</span><span class="p">(</span><span class="n">encoding</span><span class="p">))</span>

		<span class="c1"># Get text that the token represents
</span>		<span class="n">referenced_text</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="o">-</span><span class="n">offset_num</span><span class="p">:][:</span><span class="n">length_num</span><span class="p">]</span>

		<span class="n">output</span><span class="p">.</span><span class="n">extend</span><span class="p">(</span><span class="n">referenced_text</span><span class="p">)</span> <span class="c1"># referenced_text is a list of bytes so we use extend to add each one to output
</span>
		<span class="c1"># Reset length and offset
</span>		<span class="n">length</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
	<span class="k">elif</span> <span class="n">inside_token</span><span class="p">:</span>
		<span class="k">if</span> <span class="n">scanning_offset</span><span class="p">:</span>
			<span class="n">offset</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">length</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="n">output</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">char</span><span class="p">)</span> <span class="c1"># Add the character to our output
</span>

<span class="k">return</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
</code></pre></div></div>
<p>Output:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>supercalifragilisticexpialidocious supercalifragilisticexpialidocious
</code></pre></div></div>
<p>In order to calculate the piece of text that a token is referencing we can simply use our offset and length to find the text from the current output. We use a negative slice to grab all the characters backwards from <code class="language-plaintext highlighter-rouge">offset_num</code> and grab up to <code class="language-plaintext highlighter-rouge">length_num</code> elements. This results in a <code class="language-plaintext highlighter-rouge">referenced_text</code> that represents the token references. Finally we add the <code class="language-plaintext highlighter-rouge">referenced_text</code> to our output and we’re finished.</p>
<p>Lastly, we’ll only want to add a character to the output <strong>if we’re not in a token</strong> so we add an <code class="language-plaintext highlighter-rouge">else</code> to the end of our logic which only runs if we’re not in a token.</p>
<p>And that’s it! We now have a LZSS decoder, and by extension, an LZ77 decoder as decoders don’t need to worry about outputting a token only if it’s greater than the referenced text.</p>
<h2 id="implementation-conclusion"> <a href="#implementation-conclusion" class="anchor-heading" aria-labelledby="implementation-conclusion"><svg viewbox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Implementation Conclusion</h2>
<p>We’ve gone through step-by-step building an encoder and decoder and learned the purpose of each component. Let’s do some basic benchmarks to see how well it works.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">encoded</span> <span class="o">=</span> <span class="n">encode</span><span class="p">(</span><span class="n">text</span><span class="p">).</span><span class="n">decode</span><span class="p">(</span><span class="n">encoding</span><span class="p">)</span>
    <span class="n">decoded</span> <span class="o">=</span> <span class="n">decode</span><span class="p">(</span><span class="n">encoded</span><span class="p">).</span><span class="n">decode</span><span class="p">(</span><span class="n">encoding</span><span class="p">)</span>

    <span class="k">print</span><span class="p">(</span><span class="s">f"Original: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)</span><span class="si">}</span><span class="s">, Encoded: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">encoded</span><span class="p">)</span><span class="si">}</span><span class="s">, Decoded: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">decoded</span><span class="p">)</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">f"Lossless: </span><span class="si">{</span><span class="n">text</span> <span class="o">==</span> <span class="n">decoded</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">f"Compressed size: </span><span class="si">{</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">encoded</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">))</span> <span class="o">*</span> <span class="mi">100</span><span class="si">}</span><span class="s">%"</span><span class="p">)</span>
</code></pre></div></div>
<p>Using the <code class="language-plaintext highlighter-rouge">text</code> as <a href="https://www.site.uottawa.ca/~lucia/courses/2131-02/A2/trythemsource.txt">Green Eggs and Ham by Doctor Seuss</a>, we see the output:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Original: 3463 bytes, Encoded: 1912 bytes, Decoded: 3463 bytes
Lossless: True
Compressed size: 55.21224371931851%
</code></pre></div></div>
<p>LZSS just reduced the file size by 45%, not bad!</p>
<p>One thing to keep in mind is that when we refer to a “character”, we really mean a “byte”. Our loop runs byte-by-byte, not character-by-character. This distinction is minor but significant. In the world of encodings, not every character is a single byte. For example in <code class="language-plaintext highlighter-rouge">utf-8</code>, any english letter or symbol is a single byte, but more complicated characters like arabic, mandarin, or emoji characters require multiple bytes despite being a single “character”.</p>
<ul>
<li>4 bytes - 😀</li>
<li>1 byte - H</li>
<li>3 bytes - 话</li>
<li>6 bytes - يَّ</li>
</ul>
<p>If you’re interested in learning more about how bytes work, check out the Wikipedia articles on <a href="https://en.wikipedia.org/wiki/Byte">Bytes</a> and <a href="https://en.wikipedia.org/wiki/Unicode">Unicode</a>.</p>
<hr>
<footer><p><a href="#top" id="back-to-top">Back to top</a></p>
<p class="text-small text-grey-dk-000 mb-0">If you see something off, please consider <a href="https://go-compression.github.io/contributing/">contributing</a>.</p>
<div class="d-flex mt-2"><p class="text-small text-grey-dk-000 mb-0"> <a href="https://github.com/go-compression/go-compression.github.io/edit/master/site/algorithms/lzss.md" id="edit-this-page">Edit this page on GitHub.</a></p></div></footer>
</div>
</div>
<div class="search-overlay"></div>
</div>
</body>
</html>
